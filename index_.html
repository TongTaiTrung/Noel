<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Into The Memoryverse</title>
    
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10.16.4/dist/framer-motion.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

    <style>
      @import url("https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600&family=Dancing+Script:wght@500;700&family=Montserrat:wght@300;400&display=swap");

      :root { --rose-gold: #e0bfb8; --deep-pink: #be185d; }
      body { margin: 0; background-color: #050203; color: var(--rose-gold); font-family: "Montserrat", sans-serif; overflow-x: hidden; }
      ::-webkit-scrollbar { width: 0px; }
      .cinzel { font-family: "Cinzel", serif; }
      .handwriting { font-family: "Dancing Script", cursive; }

      #canvas-container { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 0; }
      /* Tăng chiều cao scroll */
      .scroll-content { height: 1500vh; width: 100%; position: relative; z-index: 10; pointer-events: none; }

      /* Romantic Loader */
      #loader {
        position: fixed; inset: 0; background: #050203; z-index: 9999;
        display: flex; flex-direction: column; align-items: center; justify-content: center; transition: opacity 1.5s ease;
      }
      .heart-loader {
        font-size: 3rem; color: var(--deep-pink); animation: heartbeat 1.5s infinite ease-in-out;
        text-shadow: 0 0 20px var(--deep-pink);
      }
      @keyframes heartbeat { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.3); } }

      .modal-glass {
        backdrop-filter: blur(16px) saturate(120%);
        background: rgba(20, 5, 10, 0.9);
        border: 1px solid rgba(224, 191, 184, 0.3);
        box-shadow: 0 0 50px rgba(190, 24, 93, 0.3);
      }
    </style>
  </head>
  <body>
    <div id="loader">
        <div class="heart-loader">❤</div>
        <p class="cinzel mt-6 text-sm tracking-[0.4em] text-pink-300/70">OPENING MEMORY TUNNEL...</p>
    </div>

    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect, useRef, useLayoutEffect } = React;
      const { motion, AnimatePresence } = window.Motion;

      // --- DỮ LIỆU KỶ NIỆM ---
      const memories = [
        { id: 1, src: "https://images.unsplash.com/photo-1523438885200-e635ba2c371e?w=600&q=80", note: "Khoảnh khắc đầu tiên ta nhìn thấy nhau.", date: "Ngày đầu tiên", color: "#fbcfe8" },
        { id: 2, src: "https://images.unsplash.com/photo-1517849845537-4d257902454a?w=600&q=80", note: "Cái nắm tay ngại ngùng giữa phố đông.", date: "Tuần thứ nhất", color: "#f9a8d4" },
        { id: 3, src: "https://images.unsplash.com/photo-1529333166437-7750a6dd5a70?w=600&q=80", note: "Nụ cười của em làm tan chảy mọi thứ.", date: "Kỷ niệm vui", color: "#ec4899" },
        { id: 4, src: "https://images.unsplash.com/photo-1516589178581-6cd7833ae3b2?w=600&q=80", note: "Những chuyến đi xa cùng nhau.", date: "Tháng thứ nhất", color: "#db2777" },
        { id: 5, src: "https://images.unsplash.com/photo-1518621736915-f3b1c41bfd00?w=600&q=80", note: "Món quà bất ngờ em dành cho anh.", date: "Ngày đặc biệt", color: "#be185d" },
        { id: 6, src: "https://images.unsplash.com/photo-1490750967868-58cb75069ed6?w=600&q=80", note: "Và tình yêu cứ thế lớn dần lên.", date: "2 Tháng bên nhau", color: "#9d174d" },
        { id: 7, src: "https://images.unsplash.com/photo-1534528741775-53994a69daeb?w=600&q=80", note: "Tương lai rực rỡ đang chờ đón.", date: "Mãi mãi", color: "#ffffff" },
      ];

      // --- THREE.JS SCENE ---
      const ThreeScene = ({ items, onSelect, scrollProgress, setLoaded }) => {
        const mountRef = useRef(null);
        const refs = useRef({ 
            scene: null, camera: null, renderer: null, composer: null, 
            gallery: new THREE.Group(), particles: null, tunnelMesh: null 
        });
        const mouse = useRef(new THREE.Vector2(0, 0));
        const targetCameraZ = useRef(15); 

        useLayoutEffect(() => {
          // 1. Setup Scene
          const scene = new THREE.Scene();
          scene.fog = new THREE.FogExp2(0x050203, 0.02);
          refs.current.scene = scene;

          const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
          camera.position.set(0, 0, 15); 
          refs.current.camera = camera;

          const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.setPixelRatio(window.devicePixelRatio);
          mountRef.current.appendChild(renderer.domElement);
          refs.current.renderer = renderer;

          // 2. Lighting
          scene.add(new THREE.AmbientLight(0xffffff, 0.1)); 
          const camLight = new THREE.PointLight(0xffd1dc, 1, 30);
          camera.add(camLight);
          scene.add(camera);
          
          const tunnelLight = new THREE.PointLight(0xd946ef, 1.5, 60);
          tunnelLight.position.set(0, 0, -50);
          scene.add(tunnelLight);

          // 3. Post-processing
          const composer = new THREE.EffectComposer(renderer);
          composer.addPass(new THREE.RenderPass(scene, camera));
          const bloomPass = new THREE.UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
          composer.addPass(bloomPass);
          refs.current.composer = composer;

          // 4. TEXTURED TUNNEL
          const loadingManager = new THREE.LoadingManager();
          loadingManager.onLoad = () => {
               anime({ targets: '#loader', opacity: 0, duration: 1500, easing: 'easeOutQuad', complete: () => {
                   document.getElementById('loader').style.display = 'none'; setLoaded(true);
               }});
          };
          const texLoader = new THREE.TextureLoader(loadingManager);

          // Nebula Texture
          const tunnelTexture = texLoader.load('https://images.unsplash.com/photo-1534796636912-3b95b3ab5980?w=1600&q=80');
          tunnelTexture.wrapS = THREE.RepeatWrapping;
          tunnelTexture.wrapT = THREE.RepeatWrapping;
          tunnelTexture.repeat.set(4, 20); 

          const tunnelGeo = new THREE.CylinderGeometry(15, 15, 1000, 32, 1, true); 
          const tunnelMat = new THREE.MeshBasicMaterial({ 
              map: tunnelTexture,
              side: THREE.BackSide,
              transparent: true,
              opacity: 0.3, 
              blending: THREE.AdditiveBlending, 
          });
          const tunnelMesh = new THREE.Mesh(tunnelGeo, tunnelMat);
          tunnelMesh.rotation.x = -Math.PI / 2;
          tunnelMesh.position.z = -200; 
          scene.add(tunnelMesh);
          refs.current.tunnelMesh = tunnelMesh;

          // 5. Gallery Frames
          scene.add(refs.current.gallery);
          const frameMat = new THREE.MeshStandardMaterial({
              color: 0x222222, metalness: 0.9, roughness: 0.1,
              emissive: 0xbe185d, emissiveIntensity: 0.2
          });

          const Z_SPACING = 30; // Khoảng cách xa hơn cho không gian

          items.forEach((item, i) => {
            texLoader.load(item.src, (tex) => {
              const geometry = new THREE.BoxGeometry(5, 3.5, 0.2);
              const materials = [
                  frameMat, frameMat, frameMat, frameMat,
                  new THREE.MeshBasicMaterial({ map: tex }),
                  frameMat
              ];
              const mesh = new THREE.Mesh(geometry, materials);
              const angle = i * 1.5; 
              const radius = 6;     
              const zPos = -i * Z_SPACING; 

              mesh.position.set(Math.cos(angle) * radius, Math.sin(angle) * radius, zPos);
              mesh.lookAt(0, 0, zPos);
              mesh.rotateY(Math.PI); 

              mesh.userData = { item, originalPos: mesh.position.clone() };
              refs.current.gallery.add(mesh);

              const borderGeo = new THREE.EdgesGeometry(geometry);
              const borderMat = new THREE.LineBasicMaterial({ color: item.color, transparent: true, opacity: 0.5 });
              const border = new THREE.LineSegments(borderGeo, borderMat);
              mesh.add(border);
            });
          });

          // 6. Particles
          const pGeo = new THREE.BufferGeometry();
          const pCount = 1500;
          const pPos = new Float32Array(pCount * 3);
          for(let i=0; i<pCount*3; i+=3) {
              const r = 8 + Math.random() * 10; 
              const theta = Math.random() * Math.PI * 2;
              pPos[i] = r * Math.cos(theta); 
              pPos[i+1] = r * Math.sin(theta); 
              pPos[i+2] = 20 - Math.random() * 200; 
          }
          pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
          const pMat = new THREE.PointsMaterial({
              color: 0xffadd2, size: 0.1, transparent: true, opacity: 0.6,
              blending: THREE.AdditiveBlending
          });
          refs.current.particles = new THREE.Points(pGeo, pMat);
          scene.add(refs.current.particles);

          // 7. Interaction
          const raycaster = new THREE.Raycaster();
          const onClick = (e) => {
            raycaster.setFromCamera(mouse.current, refs.current.camera);
            const intersects = raycaster.intersectObjects(refs.current.gallery.children, false);
            if(intersects.length > 0) onSelect(intersects[0].object.userData.item);
          };
          const onMouseMove = (e) => {
              mouse.current.x = (e.clientX / window.innerWidth) * 2 - 1;
              mouse.current.y = -(e.clientY / window.innerHeight) * 2 + 1;
          };
          window.addEventListener('click', onClick);
          window.addEventListener('mousemove', onMouseMove);
          
          // 8. Animation Loop
          const animate = () => {
            requestAnimationFrame(animate);
            const { camera, gallery, particles, composer, tunnelMesh } = refs.current;

            // Camera Move
            camera.position.z += (targetCameraZ.current - camera.position.z) * 0.05;
            camera.rotation.z = mouse.current.x * 0.05;
            camera.rotation.x = -mouse.current.y * 0.05;

            // Tunnel Animation
            if (tunnelMesh) {
                tunnelMesh.rotation.y += 0.0005; 
            }

            // Gallery Animation
            gallery.children.forEach(mesh => {
                mesh.rotation.z += 0.001;
            });

            // Particles Animation
            if(particles) {
                const positions = particles.geometry.attributes.position.array;
                for(let i=2; i<positions.length; i+=3) {
                    positions[i] += 0.2;
                    if(positions[i] > camera.position.z + 10) {
                        positions[i] = camera.position.z - 150;
                    }
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }

            composer.render();
          };
          animate();

          return () => {
            window.removeEventListener('click', onClick);
            window.removeEventListener('mousemove', onMouseMove);
            mountRef.current.innerHTML = '';
          };
        }, []);

        useEffect(() => {
             const totalDepth = items.length * 30; // Cập nhật theo Z_SPACING
             targetCameraZ.current = 15 - (scrollProgress * (totalDepth + 20));
        }, [scrollProgress, items]);

        return <div ref={mountRef} id="canvas-container" />;
      };

      // --- HERO COMPONENT (CẬP NHẬT: FADE OUT KHI SCROLL) ---
      const Hero = ({ loaded, scrollProgress }) => {
        // Opacity giảm dần khi scrollProgress tăng
        // scrollProgress chạy từ 0 đến 1
        // Fade out hoàn toàn khi scroll được khoảng 10-15%
        const opacity = Math.max(0, 1 - scrollProgress * 7); 
        
        // Di chuyển text xuống dưới một chút tạo hiệu ứng Parallax
        const yPos = scrollProgress * 500;

        return (
            <div 
                className={`fixed inset-0 flex flex-col items-center justify-center pointer-events-none z-20 transition-opacity duration-1000 ${loaded ? 'opacity-100' : 'opacity-0'}`}
                style={{ 
                    opacity: loaded ? opacity : 0,
                    transform: `translateY(${yPos}px)` 
                }}
            >
              <h1 className="cinzel text-5xl md:text-7xl text-transparent bg-clip-text bg-gradient-to-b from-pink-200 via-rose-400 to-purple-600 drop-shadow-[0_0_20px_rgba(190,24,93,0.8)] text-center">
                Into Our Memory<br/>Tunnel
              </h1>
              <div className="h-[1px] w-32 bg-rose-500/50 my-8"></div>
              {/* Đã ẩn dòng chữ Scroll to Fly */}
            </div>
        );
      };

      const Modal = ({ item, onClose }) => (
        <motion.div initial={{ opacity: 0 }} animate={{ opacity: 1 }} exit={{ opacity: 0 }} transition={{duration: 0.5}}
          className="fixed inset-0 z-[100] flex items-center justify-center p-4 bg-black/80 backdrop-blur-sm pointer-events-auto" onClick={onClose}>
          <motion.div initial={{ scale: 0.8, opacity: 0, z: -100 }} animate={{ scale: 1, opacity: 1, z: 0 }}
            className="modal-glass rounded-xl overflow-hidden max-w-5xl w-full flex flex-col md:flex-row shadow-[0_0_60px_rgba(190,24,93,0.4)]" onClick={e => e.stopPropagation()}>
            <div className="md:w-3/5 h-[50vh] md:h-auto relative overflow-hidden group">
               <img src={item.src} className="w-full h-full object-cover transition-transform duration-1000 group-hover:scale-110" />
               <div className="absolute inset-0 bg-gradient-to-t from-black/80 via-transparent to-transparent"></div>
            </div>
            <div className="md:w-2/5 p-12 flex flex-col justify-center relative bg-black/40">
              <h2 className="cinzel text-3xl text-pink-500 mb-4">{item.date}</h2>
              <div className="w-16 h-1 bg-gradient-to-r from-pink-600 to-transparent mb-8"></div>
              <p className="handwriting text-3xl text-rose-100 leading-relaxed drop-shadow-lg">"{item.note}"</p>
              <button onClick={onClose} className="mt-16 text-left text-xs uppercase tracking-[0.3em] text-rose-500 hover:text-white transition-colors">
                  Close Memory
              </button>
            </div>
          </motion.div>
        </motion.div>
      );

      const MusicPlayer = () => {
          const [playing, setPlaying] = useState(false);
          const audioRef = useRef(new Audio("https://cdn.pixabay.com/download/audio/2023/01/04/audio_06d7383140.mp3?filename=forgotten-dreams-134615.mp3"));

          const toggle = () => {
              playing ? audioRef.current.pause() : audioRef.current.play().catch(e=>console.log(e));
              setPlaying(!playing);
          }
          return (
              <button onClick={toggle} className={`fixed bottom-8 right-8 z-50 p-4 rounded-full border transition-all duration-500 ${playing ? 'border-pink-500 bg-pink-900/30 text-pink-200 shadow-[0_0_20px_var(--deep-pink)]' : 'border-white/10 bg-black/30 text-white/30'}`}>
                  {playing ? '♫' : '✕'}
              </button>
          )
      }

      const App = () => {
        const [progress, setProgress] = useState(0);
        const [selected, setSelected] = useState(null);
        const [loaded, setLoaded] = useState(false);

        useEffect(() => {
            const onScroll = () => {
                const p = window.scrollY / (document.documentElement.scrollHeight - window.innerHeight);
                setProgress(Math.min(1, Math.max(0, p)));
            };
            window.addEventListener('scroll', onScroll);
            return () => window.removeEventListener('scroll', onScroll);
        }, []);

        return (
          <>
            <div className="scroll-content" />
            <ThreeScene items={memories} onSelect={setSelected} scrollProgress={progress} setLoaded={setLoaded} />
            
            {/* Truyền scrollProgress vào Hero để xử lý Fade out */}
            <Hero loaded={loaded} scrollProgress={progress} />
            
            <MusicPlayer />
            <AnimatePresence>{selected && <Modal item={selected} onClose={() => setSelected(null)} />}</AnimatePresence>
            
            <div className="fixed bottom-6 left-6 z-40 text-[10px] tracking-[0.2em] text-pink-500/50 mix-blend-screen">
                DEPTH: {(progress * 100).toFixed(0)}%
            </div>
          </>
        );
      };

      ReactDOM.createRoot(document.getElementById("root")).render(<App />);
    </script>
  </body>
</html>